# 02. 검색-검증-병합 패턴

## 이 챕터에서 배우는 것

- Search-Verify-Merge 패턴의 개념과 이점
- 단점과 비용/속도 리스크
- 실제 구현 시 고려해야 할 설계 포인트
- LangChain/LangGraph 기반 실무 예시

---

## 1. 개념 설명과 이점

Search-Verify-Merge는 **여러 검색 결과를 검증한 뒤 병합**하는 전략입니다.
단순 병합은 노이즈를 늘리기 때문에, 검증 단계가 핵심입니다.

**이점**

- **정확도 향상**: 검증을 통과한 문서만 사용
- **노이즈 감소**: 잘못된/낡은 문서 제거
- **정책 준수**: 민감 정보나 금지어 검출 가능

---

## 2. 단점과 리스크

- **비용 증가**: LLM 검증 비용이 추가됨
- **지연 시간 증가**: 검증 단계가 병목이 될 수 있음
- **검증 편향**: 프롬프트 품질에 따라 오판 가능
- **과도한 필터링**: 지나치게 엄격하면 결과가 비어버림

---

## 3. 실제 구현 시 고려 사항

### 1) 검증 기준 문서화

- 적합성/정확성/안전성 기준을 명시
- 기준이 바뀌면 재검증 필요

### 2) 검증 범위 제한

- 상위 N개만 검증(예: Top-10)
- 전체 검증은 비용 폭증

### 3) 병합 규칙

- 통과한 결과만 병합
- 출처 다양성 확보(동일 source_id 중복 제거)

### 4) 실패/폴백

- 검증 통과 결과가 없으면 **안전한 폴백** 제공
- 검증 실패 로그/메트릭을 반드시 기록

---

## 4. 예시

```python
"""
목적: Search → Verify → Merge 흐름을 하나의 그래프로 구성한다.
설명: 검증 노드에서 LangChain LLM을 호출한다.
디자인 패턴: State Machine
"""

from typing import Any
from langgraph.graph import StateGraph, END
from langchain_openai import ChatOpenAI
from langchain_core.prompts import PromptTemplate
from langchain_core.output_parsers import StrOutputParser
from textwarp import dedent

_PROMPT = dedent(
    f"""
    You are a retrieval verifier.
    Decide if the document contains information that directly helps answer the user's question.
    Use only the document content; do not use external knowledge.
    Criteria:
    - PASS if the document is clearly relevant and contains answerable details.
    - FAIL if it is off-topic, too vague, or missing key information.
    Output exactly one token: PASS or FAIL.
    Question: {{question}}
    Document: {{content}}
    """
).strip()
_VERIFY_PROMPT = PromptTemplate(_PROMPT)


def node_search(state: dict) -> dict:
    """검색 결과를 수집한다."""
    docs = ["doc1", "doc2"]
    return {"question": state.get("question"), "docs": docs, "verified": state.get("verified", [])}


def node_verify(state: dict) -> dict:
    """LangChain LLM으로 문서를 검증한다."""
    llm = ChatOpenAI(model="gpt-4o-mini", temperature=0)
    verified: list[Any] = []
    for content in state.get("docs", []):
        result = (_VERIFY_PROMPT | llm | StrOutputParser()).invoke(
            {"question": state.get("question"), "content": content}
        )
        if result.strip().upper().startswith("PASS"):
            verified.append(content)
    return {
        "question": state.get("question"),
        "docs": state.get("docs", []),
        "verified": verified,
    }


def node_merge(state: dict) -> list[Any]:
    """검증 통과 문서만 반환한다."""
    return state.get("verified", [])


class SearchVerifyMergeGraph:
    """Search-Verify-Merge 그래프 구성 클래스."""

    def __init__(self) -> None:
        self._graph = StateGraph(dict)
        self._graph.add_node("search", node_search)
        self._graph.add_node("verify", node_verify)
        self._graph.add_node("merge", node_merge)
        self._graph.set_entry_point("search")
        self._graph.add_edge("search", "verify")
        self._graph.add_edge("verify", "merge")
        self._graph.add_edge("merge", END)

    def build(self) -> StateGraph:
        """그래프를 반환한다."""
        return self._graph
```

---

## 5. 체크리스트

- 검증 기준이 문서화되어 있는가?
- 검증 범위를 제한했는가?
- 검증 실패 시 폴백 경로가 있는가?
- 검증 결과가 로그/메트릭으로 남는가?
